"""Day17: ExecutorV3
Trajectory execution with preSolve integration.
- Executes a Cartesian trajectory generated by TrajectoryGenerator.
- Incorporates IK solver with preSolve step:
  aligns base (joint0) toward target azimuth by moving to a home pose,
  then continues with regular IK solving.
- Provides smooth joint interpolation, trajectory error reporting,
  and optional 3D visualization of ideal vs. real trajectory.
"""

import pybullet as p
import numpy as np
import matplotlib.pyplot as plt
import time


class ExecutorV3:
    def __init__(self, robot_id, ee_link_index, ik_solver, traj_gen, dof=7,
                 step_size=0.02, sleep_time=0.01):
        """
        Initialize the executor with robot, solver, and trajectory generator.
        """
        self.robot_id = robot_id
        self.ee_link_index = ee_link_index
        self.ik_solver = ik_solver
        self.traj_gen = traj_gen
        self.dof = dof
        self.step_size = step_size
        self.sleep_time = sleep_time

    def execute(self, q_init, goal_pos, down=False, plot=True, print_diff=True):
        """
        Execute trajectory from current EE position to goal_pos.
        - Runs preSolve to check base alignment against target azimuth.
        - If not aligned, moves to an aligned home pose before solving IK.
        - Solves IK for each interpolated waypoint and applies joint motion.
        - Collects and reports trajectory tracking error.
        - Optionally plots ideal vs. real trajectory.
        """
        # Current end-effector position
        ls = p.getLinkState(self.robot_id, self.ee_link_index, computeForwardKinematics=True)
        cur_pos = np.array(ls[4])

        # Interpolate Cartesian trajectory
        traj_ideal = self.traj_gen.interpolate(cur_pos, goal_pos)
        traj_real = [cur_pos.tolist()]
        q_traj = [q_init]
        q_cur = np.array(q_init, dtype=float)
        errors = []

        # i = 1
        # while i < len(traj_ideal):
        #     target_pos = np.array(traj_ideal[i])
        #
        #     # PreSolve: base alignment
        #     aligned, aligned_q_init = self.ik_solver.preSolve(q_cur, traj_ideal[-1])
        #     if not aligned:
        #         self._move_joints_smoothly(q_cur, np.array(aligned_q_init))
        #         ls = p.getLinkState(self.robot_id, self.ee_link_index, computeForwardKinematics=True)
        #         cur_pos = np.array(ls[4])
        #         traj_ideal = self.traj_gen.interpolate(cur_pos, traj_ideal[-1])
        #         q_cur = aligned_q_init
        #         continue
        #
        #     # IK solve for current waypoint
        #     q_cur = aligned_q_init
        #     q_sol, _ = self.ik_solver.solve(q_cur, target_pos, down=down)
        #     q_sol = np.array(q_sol, dtype=float)
        #     self._move_joints_smoothly(q_cur, q_sol)
        #
        #     # Update joint state
        #     q_cur = q_sol.copy()
        #     q_traj.append(q_cur.tolist())
        #
        #     # Record real EE position
        #     ls = p.getLinkState(self.robot_id, self.ee_link_index, computeForwardKinematics=True)
        #     real_pos = np.array(ls[4])
        #     traj_real.append(real_pos.tolist())
        #
        #     # Track error
        #     pos_diff = np.linalg.norm(target_pos - real_pos)
        #     errors.append(pos_diff)
        #     if print_diff:
        #         print(f"Step {i}: target={target_pos}, real={real_pos}, diff={pos_diff:.6f}")
        #
        #     i += 1

        i = 0
        while i < len(traj_ideal):
            target_pos = np.array(traj_ideal[i])

            # PreSolve: base alignment
            aligned, aligned_q_init = self.ik_solver.preSolve(q_cur, traj_ideal[-1])
            if not aligned:
                # 執行 preSolve 的移動，但不要記錄進 traj_real
                self._move_joints_smoothly(q_cur, np.array(aligned_q_init))
                # 更新當前 joint 狀態
                q_cur = np.array(aligned_q_init)
                # 更新 EE 真實位置
                ls = p.getLinkState(self.robot_id, self.ee_link_index, computeForwardKinematics=True)
                cur_pos = np.array(ls[4])
                # 重新生成插值（從新位置到最後目標）
                traj_ideal = self.traj_gen.interpolate(cur_pos, traj_ideal[-1])
                i = 0  # 重新從第一個新 waypoint 開始
                continue

            # IK solve for current waypoint
            q_sol, _ = self.ik_solver.solve(q_cur, target_pos, down=down)
            q_sol = np.array(q_sol, dtype=float)

            # 執行 joint 動作
            self._move_joints_smoothly(q_cur, q_sol)
            q_cur = q_sol.copy()
            q_traj.append(q_cur.tolist())

            # 記錄真實 EE 位置
            ls = p.getLinkState(self.robot_id, self.ee_link_index, computeForwardKinematics=True)
            real_pos = np.array(ls[4])
            traj_real.append(real_pos.tolist())

            # Track error
            pos_diff = np.linalg.norm(target_pos - real_pos)
            errors.append(pos_diff)
            if print_diff:
                print(f"Step {i}: target={target_pos}, real={real_pos}, diff={pos_diff:.6f}")

            i += 1
        # Error report
        if errors:
            mean_err = np.mean(errors)
            max_err = np.max(errors)
            min_err = np.min(errors)
            print("\n=== Trajectory Error Summary ===")
            print(f"Mean Error: {mean_err:.6f}")
            print(f"Max Error : {max_err:.6f}")
            print(f"Min Error : {min_err:.6f}")

        if plot:
            self.plot_trajectory(traj_ideal, traj_real)

        # Freeze final state
        # self._freeze_kinematic(self.robot_id, self.dof, q_cur, frames=60)

        return q_traj, (traj_ideal, traj_real)

    def _move_joints_smoothly(self, q_start, q_end):
        """
        Linearly interpolate joint motion from q_start to q_end with small steps.
        """
        diff = q_end - q_start
        n_steps = int(np.max(np.abs(diff)) / self.step_size) + 1

        for alpha in np.linspace(0, 1, n_steps):
            q_interp = (1 - alpha) * q_start + alpha * q_end
            for j in range(self.dof):
                p.resetJointState(self.robot_id, j, float(q_interp[j]), targetVelocity=0.0)
            p.stepSimulation()
            time.sleep(self.sleep_time)

    def _freeze_kinematic(self, robot_id, dof, q_target, frames=240):
        """
        Hold the robot at target configuration for a given number of frames.
        """
        p.setJointMotorControlArray(
            bodyUniqueId=robot_id,
            jointIndices=range(dof),
            controlMode=p.POSITION_CONTROL,
            targetPositions=q_target,
            positionGains=[0.01]*dof,
            velocityGains=[0.1]*dof
        )
        for _ in range(frames):
            p.stepSimulation()
            time.sleep(1. / 240.)

    def plot_trajectory(self, traj_ideal, traj_real):
        """
        Plot 3D comparison of ideal vs. real trajectory.
        """
        traj_ideal = np.array(traj_ideal)
        traj_real = np.array(traj_real)

        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")
        ax.plot(traj_ideal[:, 0], traj_ideal[:, 1], traj_ideal[:, 2], "b--", label="Ideal")
        ax.scatter(traj_ideal[:, 0], traj_ideal[:, 1], traj_ideal[:, 2], c="b", marker="o")
        ax.plot(traj_real[:, 0], traj_real[:, 1], traj_real[:, 2], "r-", label="Real")
        ax.scatter(traj_real[:, 0], traj_real[:, 1], traj_real[:, 2], c="r", marker="x")

        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")
        ax.legend()
        ax.set_title("Trajectory Comparison")
        plt.show()
